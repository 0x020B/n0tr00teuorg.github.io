{"version":3,"file":"token.cjs","sources":["../../src/token.js"],"sourcesContent":["import { pack } from 'ipfs-car/pack'\r\nimport { CID } from 'multiformats/cid'\r\nimport * as Block from 'multiformats/block'\r\nimport { sha256 } from 'multiformats/hashes/sha2'\r\nimport * as dagCbor from '@ipld/dag-cbor'\r\nimport { Blob, FormData, Blockstore } from './platform.js'\r\nimport { toGatewayURL, GATEWAY } from './gateway.js'\r\n\r\n/**\r\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\r\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\r\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\r\n */\r\n\r\n/**\r\n * @template T\r\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\r\n */\r\n\r\n/**\r\n * @template G\r\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\r\n */\r\n\r\n/**\r\n * @template {import('./lib/interface.js').TokenInput} T\r\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\r\n */\r\n\r\n/**\r\n * @template {TokenInput} T\r\n * @implements {TokenType<T>}\r\n */\r\nexport class Token {\r\n  /**\r\n   * @param {import('./lib/interface.js').CIDString} ipnft\r\n   * @param {import('./lib/interface.js').EncodedURL} url\r\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\r\n   */\r\n  constructor(ipnft, url, data) {\r\n    /** @readonly */\r\n    this.ipnft = ipnft\r\n    /** @readonly */\r\n    this.url = url\r\n    /** @readonly */\r\n    this.data = data\r\n\r\n    Object.defineProperties(this, {\r\n      ipnft: { enumerable: true, writable: false },\r\n      url: { enumerable: true, writable: false },\r\n      data: { enumerable: false, writable: false },\r\n    })\r\n  }\r\n  /**\r\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\r\n   */\r\n  embed() {\r\n    return Token.embed(this)\r\n  }\r\n\r\n  /**\r\n   * @template {TokenInput} T\r\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\r\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\r\n   */\r\n  static embed({ data }) {\r\n    return embed(data, { gateway: GATEWAY })\r\n  }\r\n\r\n  /**\r\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\r\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\r\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\r\n   * prefixed CID with an optional path).\r\n   *\r\n   * @example\r\n   * ```js\r\n   * const cat = new File(['...'], 'cat.png')\r\n   * const kitty = new File(['...'], 'kitty.png')\r\n   * const { token, car } = await Token.encode({\r\n   *   name: 'hello'\r\n   *   image: cat\r\n   *   properties: {\r\n   *     extra: {\r\n   *       image: kitty\r\n   *     }\r\n   *   }\r\n   * })\r\n   * ```\r\n   *\r\n   * @template {TokenInput} T\r\n   * @param {T} input\r\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: AsyncIterable<Uint8Array> }>}\r\n   */\r\n  static async encode(input) {\r\n    const blockstore = new Blockstore()\r\n    const [blobs, meta] = mapTokenInputBlobs(input)\r\n    /** @type {EncodedBlobUrl<T>} */\r\n    const data = JSON.parse(JSON.stringify(meta))\r\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\r\n    const dag = JSON.parse(JSON.stringify(meta))\r\n\r\n    for (const [dotPath, blob] of blobs.entries()) {\r\n      /** @type {string|undefined} */\r\n      // @ts-ignore blob may be a File!\r\n      const name = blob.name || 'blob'\r\n      /** @type {import('./platform.js').ReadableStream} */\r\n      const content = blob.stream()\r\n      const { root: cid } = await pack({\r\n        input: [{ path: name, content }],\r\n        blockstore,\r\n        wrapWithDirectory: true,\r\n      })\r\n\r\n      const href = new URL(`ipfs://${cid}/${name}`)\r\n      const path = dotPath.split('.')\r\n      setIn(data, path, href)\r\n      setIn(dag, path, cid)\r\n    }\r\n\r\n    const { root: metadataJsonCid, out } = await pack({\r\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\r\n      blockstore,\r\n      wrapWithDirectory: false,\r\n    })\r\n\r\n    const block = await Block.encode({\r\n      value: {\r\n        ...dag,\r\n        'metadata.json': metadataJsonCid,\r\n        type: 'nft',\r\n      },\r\n      codec: dagCbor,\r\n      hasher: sha256,\r\n    })\r\n    await blockstore.put(block.cid, block.bytes)\r\n\r\n    return {\r\n      cid: block.cid,\r\n      token: new Token(\r\n        block.cid.toString(),\r\n        `ipfs://${block.cid}/metadata.json`,\r\n        data\r\n      ),\r\n      car: out\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {EncodedBlobUrl<T>} input\r\n * @param {EmbedOptions} options\r\n * @returns {EncodedBlobUrl<T>}\r\n */\r\nexport const embed = (input, options) =>\r\n  mapWith(input, isURL, embedURL, options)\r\n\r\n/**\r\n * @template {TokenInput} T\r\n * @param {import('./lib/interface.js').EncodedToken<T>} value\r\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\r\n * @returns {Token<T>}\r\n */\r\nexport const decode = ({ ipnft, url, data }, paths) =>\r\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\r\n\r\n/**\r\n * @param {any} value\r\n * @returns {value is URL}\r\n */\r\nconst isURL = (value) => value instanceof URL\r\n\r\n/**\r\n * @template State\r\n * @param {State} state\r\n * @param {import('./lib/interface.js').EncodedURL} url\r\n * @returns {[State, URL]}\r\n */\r\nconst decodeURL = (state, url) => [state, new URL(url)]\r\n\r\n/**\r\n * @param {EmbedOptions} context\r\n * @param {URL} url\r\n * @returns {[EmbedOptions, URL]}\r\n */\r\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\r\n\r\n/**\r\n * @param {any} value\r\n * @returns {value is object}\r\n */\r\nconst isObject = (value) => typeof value === 'object' && value != null\r\n\r\n/**\r\n * @param {any} value\r\n * @param {Set<string>} assetPaths\r\n * @param {PropertyKey[]} path\r\n * @returns {value is import('./lib/interface.js').EncodedURL}\r\n */\r\nconst isEncodedURL = (value, assetPaths, path) =>\r\n  typeof value === 'string' && assetPaths.has(path.join('.'))\r\n\r\n/**\r\n * Takes token input and encodes it into\r\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\r\n * object where form field values are discovered `Blob` (or `File`) objects in\r\n * the given token and field keys are `.` joined paths where they were discoverd\r\n * in the token. Additionally encoded `FormData` will also have a field\r\n * named `meta` containing JSON serialized token with blobs and file values\r\n * `null` set to null (this allows backend to injest all of the files from\r\n * `multipart/form-data` request and update provided \"meta\" data with\r\n * corresponding file ipfs:// URLs)\r\n *\r\n * @example\r\n * ```js\r\n * const cat = new File([], 'cat.png')\r\n * const kitty = new File([], 'kitty.png')\r\n * const form = encode({\r\n *   name: 'hello'\r\n *   image: cat\r\n *   properties: {\r\n *     extra: {\r\n *       image: kitty\r\n *     }\r\n *   }\r\n * })\r\n * [...form.entries()] //>\r\n * // [\r\n * //   ['image', cat],\r\n * //   ['properties.extra.image', kitty],\r\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\r\n * // ]\r\n * ```\r\n *\r\n * @template {TokenInput} T\r\n * @param {EncodedBlobBlob<T>} input\r\n * @returns {FormData}\r\n */\r\nexport const encode = (input) => {\r\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\r\n  const form = new FormData()\r\n  for (const [k, v] of map.entries()) {\r\n    form.set(k, v)\r\n  }\r\n  form.set('meta', JSON.stringify(meta))\r\n  return form\r\n}\r\n\r\n/**\r\n * @param {Map<string, Blob>} data\r\n * @param {Blob} blob\r\n * @param {PropertyKey[]} path\r\n * @returns {[Map<string, Blob>, void]}\r\n */\r\nconst encodeBlob = (data, blob, path) => {\r\n  data.set(path.join('.'), blob)\r\n  return [data, undefined]\r\n}\r\n\r\n/**\r\n * @param {any} value\r\n * @returns {value is Blob}\r\n */\r\nconst isBlob = (value) => value instanceof Blob\r\n\r\n/**\r\n * @template {TokenInput} T\r\n * @param {EncodedBlobBlob<T>} input\r\n */\r\nconst mapTokenInputBlobs = (input) => {\r\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\r\n}\r\n\r\n/**\r\n * Substitues values in the given `input` that match `p(value) == true` with\r\n * `f(value, context, path)` where `context` is whatever you pass (usually\r\n * a mutable state) and `path` is a array of keys / indexes where the value\r\n * was encountered.\r\n *\r\n * @template T, I, X, O, State\r\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\r\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\r\n * which values to swap.\r\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\r\n * that swaps matching values.\r\n * @param {State} state - Some additional context you need in the process.\r\n * likey you'll start with `[]`.\r\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\r\n */\r\nexport const mapWith = (input, p, f, state) => {\r\n  const [, output] = mapValueWith(input, p, f, state, [])\r\n  return output\r\n}\r\n\r\n/**\r\n * @template T, I, X, O, State\r\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\r\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\r\n * which values to swap.\r\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\r\n * that swaps matching values.\r\n * @param {State} state - Some additional context you need in the process.\r\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\r\n * likey you'll start with `[]`.\r\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\r\n */\r\nconst mapValueWith = (input, p, f, state, path) =>\r\n  p(input, state, path)\r\n    ? f(state, input, path)\r\n    : Array.isArray(input)\r\n    ? mapArrayWith(input, p, f, state, path)\r\n    : isObject(input)\r\n    ? mapObjectWith(input, p, f, state, path)\r\n    : [state, /** @type {any} */ (input)]\r\n\r\n/**\r\n * Just like `mapWith` except\r\n *\r\n * @template State, T, I, X, O\r\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\r\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\r\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\r\n * @param {State} init\r\n * @param {PropertyKey[]} path\r\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\r\n */\r\nconst mapObjectWith = (input, p, f, init, path) => {\r\n  let state = init\r\n  const output =\r\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\r\n  for (const [key, value] of Object.entries(input)) {\r\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\r\n    // @ts-ignore\r\n    output[key] = out\r\n    state = next\r\n  }\r\n  return [state, output]\r\n}\r\n\r\n/**\r\n * Just like `mapWith` except for Arrays.\r\n *\r\n * @template I, X, O, State\r\n * @template {any[]} T\r\n * @param {T} input\r\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\r\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\r\n * @param {State} init\r\n * @param {PropertyKey[]} path\r\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\r\n */\r\nconst mapArrayWith = (input, p, f, init, path) => {\r\n  const output = /** @type {unknown[]} */ ([])\r\n\r\n  let state = init\r\n  for (const [index, element] of input.entries()) {\r\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\r\n    output[index] = out\r\n    state = next\r\n  }\r\n\r\n  return [\r\n    state,\r\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\r\n  ]\r\n}\r\n\r\n/**\r\n * Sets a given `value` at the given `path` on a passed `object`.\r\n *\r\n * @example\r\n * ```js\r\n * const obj = { a: { b: { c: 1 }}}\r\n * setIn(obj, ['a', 'b', 'c'], 5)\r\n * obj.a.b.c //> 5\r\n * ```\r\n *\r\n * @template V\r\n * @param {any} object\r\n * @param {string[]} path\r\n * @param {V} value\r\n */\r\nconst setIn = (object, path, value) => {\r\n  const n = path.length - 1\r\n  let target = object\r\n  for (let [index, key] of path.entries()) {\r\n    if (index === n) {\r\n      target[key] = value\r\n    } else {\r\n      target = target[key]\r\n    }\r\n  }\r\n}\r\n"],"names":["GATEWAY","Blockstore","pack","Block","dagCbor","sha256","toGatewayURL","FormData","Blob"],"mappings":"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"}